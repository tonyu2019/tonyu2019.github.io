<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.1.1"><link rel="apple-touch-icon" sizes="180x180" href="/images/56x56logo.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/56x56logo.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon.ico"><link rel="mask-icon" href="/images/400x400logo.png" color="#222"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css"><script class="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"www.diandian100.cn",root:"/",scheme:"Gemini",version:"8.0.0",exturl:!0,sidebar:{position:"left",display:"always",padding:18,offset:12},copycode:!0,bookmark:{enable:!1,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!0,lazyload:!0,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"fadeInDown",post_body:"fadeInDown",coll_header:"fadeInLeft",sidebar:"fadeInUp"}},prism:!1,i18n:{placeholder:"搜索...",empty:"没有找到任何搜索结果：${query}",hits_time:"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）",hits:"找到 ${hits} 个搜索结果"},path:"search.xml",localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1}}</script><meta name="description" content="进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体"><meta property="og:type" content="article"><meta property="og:title" content="python中的进程"><meta property="og:url" content="https://www.diandian100.cn/df26ec49.html"><meta property="og:site_name" content="点点开发技术分享"><meta property="og:description" content="进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体"><meta property="og:locale" content="zh_CN"><meta property="article:published_time" content="2019-07-25T02:12:59.000Z"><meta property="article:modified_time" content="2020-09-04T01:49:44.000Z"><meta property="article:author" content="托小尼"><meta property="article:tag" content="Process"><meta property="article:tag" content="进程"><meta property="article:tag" content="线程"><meta property="article:tag" content="python进程"><meta property="article:tag" content="python线程"><meta property="article:tag" content="threding"><meta property="article:tag" content="gil"><meta property="article:tag" content="nptl"><meta name="twitter:card" content="summary"><link rel="canonical" href="https://www.diandian100.cn/df26ec49.html"><script class="page-configurations">CONFIG.page={sidebar:"",isHome:!1,isPost:!0,lang:"zh-CN"}</script><title>python中的进程 | 点点开发技术分享</title><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?3b57832214417f66931e694d19fd60b9";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar{visibility:visible}.use-motion .footer,.use-motion .header,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript></head><body itemscope itemtype="http://schema.org/WebPage" class="use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="切换导航栏"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">点点开发技术分享</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">记录个人日常开发笔记与技巧</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li><li class="menu-item menu-item-development"><a href="/categories/rd/" rel="section"><i class="fa fa-code fa-fw"></i>开发</a></li><li class="menu-item menu-item-frontend"><a href="/categories/fe/" rel="section"><i class="fab fa-html5 fa-fw"></i>前端</a></li><li class="menu-item menu-item-database"><a href="/categories/db/" rel="section"><i class="fa fa-database fa-fw"></i>数据库</a></li><li class="menu-item menu-item-os"><a href="/categories/os/" rel="section"><i class="fab fa-linux fa-fw"></i>系统</a></li><li class="menu-item menu-item-other"><a href="/categories/other/" rel="section"><i class="far fa-paper-plane fa-fw"></i>其他</a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" maxlength="80" placeholder="搜索..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class="search-result-icon"><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line"></span> <span class="toggle-line"></span> <span class="toggle-line"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">文章目录</li><li class="sidebar-nav-overview">站点概览</li></ul><section class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BA%BF%E7%A8%8B%E7%90%86%E8%AE%BA"><span class="nav-number">2.</span> <span class="nav-text">操作系统线程理论</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E7%9A%84%E5%BC%95%E5%85%A5%E8%83%8C%E6%99%AF"><span class="nav-number">2.1.</span> <span class="nav-text">线程概念的引入背景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-number">2.2.</span> <span class="nav-text">进程和线程的关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%89%B9%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">线程的特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E9%99%85%E5%9C%BA%E6%99%AF"><span class="nav-number">2.4.</span> <span class="nav-text">使用线程的实际场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E5%AD%98%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.5.</span> <span class="nav-text">内存中的线程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">用户级线程和内核级线程（了解）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.1.</span> <span class="nav-text">用户级线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.6.2.</span> <span class="nav-text">内核级线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E6%88%B7%E7%BA%A7%E4%B8%8E%E5%86%85%E6%A0%B8%E7%BA%A7%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="nav-number">2.6.3.</span> <span class="nav-text">用户级与内核级线程的对比</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.6.4.</span> <span class="nav-text">混合实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84-NPTL"><span class="nav-number">2.6.5.</span> <span class="nav-text">　　linux操作系统的 NPTL　　　　</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E5%92%8Cpython"><span class="nav-number">3.</span> <span class="nav-text">线程和python</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%90%86%E8%AE%BA%E7%9F%A5%E8%AF%86"><span class="nav-number">3.1.</span> <span class="nav-text">理论知识</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81GIL"><span class="nav-number">3.1.1.</span> <span class="nav-text">全局解释器锁GIL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#python%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97%E7%9A%84%E9%80%89%E6%8B%A9"><span class="nav-number">3.1.2.</span> <span class="nav-text">python线程模块的选择</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#threading%E6%A8%A1%E5%9D%97"><span class="nav-number">3.2.</span> <span class="nav-text">threading模块</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BAThreading-Thread%E7%B1%BB"><span class="nav-number">3.2.1.</span> <span class="nav-text">线程的创建Threading.Thread类</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%94%81"><span class="nav-number">3.3.</span> <span class="nav-text">锁</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%94%81%E4%B8%8EGIL"><span class="nav-number">3.3.1.</span> <span class="nav-text">锁与GIL</span></a></li><li class="nav-item nav-level-4"><a class="nav-link"><span class="nav-number">3.3.2.</span> <span class="nav-text"></span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%90%8C%E6%AD%A5%E9%94%81"><span class="nav-number">3.3.3.</span> <span class="nav-text">同步锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E9%80%92%E5%BD%92%E9%94%81"><span class="nav-number">3.3.4.</span> <span class="nav-text">死锁与递归锁</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E9%98%9F%E5%88%97"><span class="nav-number">3.4.</span> <span class="nav-text">线程队列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Python%E6%A0%87%E5%87%86%E6%A8%A1%E5%9D%97%E2%80%93concurrent-futures"><span class="nav-number">3.5.</span> <span class="nav-text">Python标准模块–concurrent.futures</span></a></li></ol></li></ol></div></section><section class="site-overview-wrap sidebar-panel"><div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="托小尼" src="/images/avatar.jpg"><p class="site-author-name" itemprop="name">托小尼</p><div class="site-description" itemprop="description"></div></div><div class="site-state-wrap animated"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">199</span> <span class="site-state-item-name">日志</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">30</span> <span class="site-state-item-name">分类</span></a></div><div class="site-state-item site-state-tags"><a href="/tags/"><span class="site-state-item-count">1269</span> <span class="site-state-item-name">标签</span></a></div></nav></div><div class="links-of-author animated"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cDovL3dwYS5xcS5jb20vbXNncmQ/dj0zJnVpbj02NDY1NDc5ODkmc2l0ZT1xcSZtZW51PXllcw==" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;646547989&amp;site&#x3D;qq&amp;menu&#x3D;yes"><i class="fab fa-qq fa-fw"></i>QQ</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOnRvbnl5dUB2aXAucXEuY29t" title="E-Mail → mailto:tonyyu@vip.qq.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span></span></div></section></div></aside><div class="sidebar-dimmer"></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL3Rvbnl1MjAxOQ==" title="关注我" aria-label="关注我"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div class="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://www.diandian100.cn/df26ec49.html"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="托小尼"><meta itemprop="description" content=""></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="点点开发技术分享"></span><header class="post-header"><h1 class="post-title" itemprop="name headline">python中的进程</h1><div class="post-meta-container"><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">发表于</span> <time title="创建时间：2019-07-25 10:12:59" itemprop="dateCreated datePublished" datetime="2019-07-25T10:12:59+08:00">2019-07-25</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">更新于</span> <time title="修改时间：2020-09-04 09:49:44" itemprop="dateModified" datetime="2020-09-04T09:49:44+08:00">2020-09-04</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">分类于</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rd/" itemprop="url" rel="index"><span itemprop="name">rd</span></a> </span>， <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/rd/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a> </span></span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-comment"></i> </span><span class="post-meta-item-text">Changyan：</span> <a title="changyan" href="/df26ec49.html#SOHUCS" itemprop="discussionUrl"><span id="changyan_count_unit" class="post-comments-count hc-comment-count" data-xid="df26ec49.html" itemprop="commentCount"></span></a></span></div><div class="post-meta"><span class="post-meta-item" title="本文字数"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">本文字数：</span> <span>23k</span> </span><span class="post-meta-item" title="阅读时长"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">阅读时长 &asymp;</span> <span>21 分钟</span></span></div></div></header><div class="post-body" itemprop="articleBody"><p>进程（<code>Process</code>）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体</p><a id="more"></a><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>操作系统线程理论</p><ul><li>​ 线程概念的引入背景</li><li>​ 线程的特点</li><li>​ 进程和线程的关系</li><li>​ 使用线程的实际场景</li><li>​ 用户级线程和内核级线程(了解)</li></ul><p>线程和<code>python</code></p><ul><li>​ 理论知识</li><li>​ 线程的创建<code>Threading.Thread</code>类</li><li>​ 锁</li><li>​ 队列</li><li>​ <code>Python</code>标准模块–<code>concurrent.futures</code></li></ul><hr><h2 id="操作系统线程理论"><a href="#操作系统线程理论" class="headerlink" title="操作系统线程理论"></a>操作系统线程理论</h2><h3 id="线程概念的引入背景"><a href="#线程概念的引入背景" class="headerlink" title="线程概念的引入背景"></a>线程概念的引入背景</h3><p><strong>进程</strong></p><p>　　之前我们已经了解了操作系统中进程的概念，程序并不能单独运行，只有将程序装载到内存中，系统为它分配资源才能运行，而这种执行的程序就称之为进程。程序和进程的区别就在于：程序是指令的集合，它是进程运行的静态描述文本；进程是程序的一次执行活动，属于动态概念。在多道编程中，我们允许多个程序同时加载到内存中，在操作系统的调度下，可以实现并发地执行。这是这样的设计，大大提高了CPU的利用率。进程的出现让每个用户感觉到自己独享CPU，因此，进程就是为了在CPU上实现多道编程而提出的。</p><p><strong>有了进程为什么要有线程</strong></p><p>　　进程有很多优点，它提供了多道编程，让我们感觉我们每个人都拥有自己的CPU和其他资源，可以提高计算机的利用率。很多人就不理解了，既然进程这么优秀，为什么还要线程呢？其实，仔细观察就会发现进程还是有很多缺陷的，主要体现在两点上：</p><ul><li>进程只能在一个时间干一件事，如果想同时干两件事或多件事，进程就无能为力了。</li><li>进程在执行的过程中如果阻塞，例如等待输入，整个进程就会挂起，即使进程中有些工作不依赖于输入的数据，也将无法执行。</li></ul><p>　　如果这两个缺点理解比较困难的话，举个现实的例子也许你就清楚了：如果把我们上课的过程看成一个进程的话，那么我们要做的是耳朵听老师讲课，手上还要记笔记，脑子还要思考问题，这样才能高效的完成听课的任务。而如果只提供进程这个机制的话，上面这三件事将不能同时执行，同一时间只能做一件事，听的时候就不能记笔记，也不能用脑子思考，这是其一；如果老师在黑板上写演算过程，我们开始记笔记，而老师突然有一步推不下去了，阻塞住了，他在那边思考着，而我们呢，也不能干其他事，即使你想趁此时思考一下刚才没听懂的一个问题都不行，这是其二。</p><p>　　现在你应该明白了进程的缺陷了，而解决的办法很简单，我们完全可以让听、写、思三个独立的过程，并行起来，这样很明显可以提高听课的效率。而实际的操作系统中，也同样引入了这种类似的机制——线程。</p><p><strong>线程的出现</strong></p><p>　　60年代，在OS中能拥有资源和独立运行的基本单位是进程，然而随着计算机技术的发展，进程出现了很多弊端，一是由于进程是资源拥有者，创建、撤消与切换存在较大的时空开销，因此需要引入轻型进程；二是由于对称多处理机（<code>SMP</code>）出现，可以满足多个运行单位，而多个进程并行开销过大。</p><p>　　因此在80年代，出现了能独立运行的基本单位——线程（<code>Threads</code>）。　</p><h3 id="进程和线程的关系"><a href="#进程和线程的关系" class="headerlink" title="进程和线程的关系"></a>进程和线程的关系</h3><p>线程与进程的区别可以归纳为以下4点：</p><ol><li>地址空间和其它资源（如打开文件）：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。</li><li>通信：进程间通信IPC，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。</li><li>调度和切换：线程上下文切换比进程上下文切换要快得多。</li><li>在多线程操作系统中，进程不是一个可执行的实体。</li></ol><p>　　*<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTMvMDQvcHJvY2Vzc2VzX2FuZF90aHJlYWRzLmh0bWw=">通过阮一峰博客漫画了解线程进程<i class="fa fa-external-link-alt"></i></span></p><h3 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h3><p>　在多线程的操作系统中，通常是在一个进程中包括多个线程，每个线程都是作为利用CPU的基本单位，是花费最小开销的实体。线程具有以下属性。</p><p>　　1）轻型实体</p><p>　　线程中的实体基本上不拥有系统资源，只是有一点必不可少的、能保证独立运行的资源。</p><p>　　线程的实体包括程序、数据和<code>TCB</code>。线程是动态概念，它的动态特性由线程控制块<code>TCB</code>（<code>Thread Control Block</code>）描述。</p><p><code>TCB</code>包括以下信息：</p><ol><li>（1）线程状态。</li><li>（2）当线程不运行时，被保存的现场资源。</li><li>（3）一组执行堆栈。</li><li>（4）存放每个线程的局部变量主存区。</li><li>（5）访问同一个进程中的主存和其它资源。</li></ol><p>用于指示被执行指令序列的程序计数器、保留局部变量、少数状态参数和返回地址等的一组寄存器和堆栈。</p><p>　　2）独立调度和分派的基本单位。</p><p>　　在多线程OS中，线程是能独立运行的基本单位，因而也是独立调度和分派的基本单位。由于线程很“轻”，故线程的切换非常迅速且开销小（在同一进程中的）。</p><p>　　3）共享进程资源。</p><p>　　线程在同一进程中的各个线程，都可以共享该进程所拥有的资源，这首先表现在：所有线程都具有相同的进程id，这意味着，线程可以访问该进程的每一个内存资源；此外，还可以访问进程所拥有的已打开文件、定时器、信号量机构等。由于同一个进程内的线程共享内存和文件，所以线程之间互相通信不必调用内核。</p><p>　　4）可并发执行。</p><p>　　在一个进程中的多个线程之间，可以并发执行，甚至允许在一个进程中所有线程都能并发执行；同样，不同进程中的线程也能并发执行，充分利用和发挥了处理机与外围设备并行工作的能力。</p><h3 id="使用线程的实际场景"><a href="#使用线程的实际场景" class="headerlink" title="使用线程的实际场景"></a>使用线程的实际场景</h3><p>开启一个字处理软件进程，该进程肯定需要办不止一件事情，比如监听键盘输入，处理文字，定时自动将文字保存到硬盘，这三个任务操作的都是同一块数据，因而不能用多进程。只能在一个进程里并发地开启三个线程,如果是单线程，那就只能是，键盘输入时，不能处理文字和自动保存，自动保存时又不能输入和处理文字。</p><h3 id="内存中的线程"><a href="#内存中的线程" class="headerlink" title="内存中的线程"></a>内存中的线程</h3><p>多个线程共享同一个进程的地址空间中的资源，是对一台计算机上多个进程的模拟，有时也称线程为轻量级的进程。</p><p>　　而对一台计算机上多个进程，则共享物理内存、磁盘、打印机等其他物理资源。多线程的运行也多进程的运行类似，是cpu在多个线程之间的快速切换。</p><p>　　不同的进程之间是充满敌意的，彼此是抢占、竞争cpu的关系，如果迅雷会和QQ抢资源。而同一个进程是由一个程序员的程序创建，所以同一进程内的线程是合作关系，一个线程可以访问另外一个线程的内存地址，大家都是共享的，一个线程干死了另外一个线程的内存，那纯属程序员脑子有问题。</p><p>　　类似于进程，每个线程也有自己的堆栈，不同于进程，线程库无法利用时钟中断强制线程让出CPU，可以调用thread_yield运行线程自动放弃cpu，让另外一个线程运行。</p><p>　　线程通常是有益的，但是带来了不小程序设计难度，线程的问题是：</p><p>　　1. 父进程有多个线程，那么开启的子线程是否需要同样多的线程</p><p>　　2. 在同一个进程中，如果一个线程关闭了文件，而另外一个线程正准备往该文件内写内容呢？</p><p>　　因此，在多线程的代码中，需要更多的心思来设计程序的逻辑、保护程序的数据。</p><h3 id="用户级线程和内核级线程（了解）"><a href="#用户级线程和内核级线程（了解）" class="headerlink" title="用户级线程和内核级线程（了解）"></a>用户级线程和内核级线程（了解）</h3><p>线程的实现可以分为两类：用户级线程(User-Level Thread)和内核线线程(Kernel-Level Thread)，后者又称为内核支持的线程或轻量级进程。在多线程操作系统中，各个系统的实现方式并不相同，在有的系统中实现了用户级线程，有的系统中实现了内核级线程。</p><h4 id="用户级线程"><a href="#用户级线程" class="headerlink" title="用户级线程"></a>用户级线程</h4><p>　　内核的切换由用户态程序自己控制内核切换,不需要内核干涉，少了进出内核态的消耗，但不能很好的利用多核Cpu。</p><p>　　在用户空间模拟操作系统对进程的调度，来调用一个进程中的线程，每个进程中都会有一个运行时系统，用来调度线程。此时当该进程获取cpu时，进程内再调度出一个线程去执行，同一时刻只有一个线程执行。</p><h4 id="内核级线程"><a href="#内核级线程" class="headerlink" title="内核级线程"></a>内核级线程</h4><p>　　 内核级线程:切换由内核控制，当线程进行切换的时候，由用户态转化为内核态。切换完毕要从内核态返回用户态；可以很好的利用smp，即利用多核cpu。windows线程就是这样的。</p><p>　</p><h4 id="用户级与内核级线程的对比"><a href="#用户级与内核级线程的对比" class="headerlink" title="用户级与内核级线程的对比"></a>用户级与内核级线程的对比</h4><p>1 内核支持线程是OS内核可感知的，而用户级线程是OS内核不可感知的。</p><p>2 用户级线程的创建、撤消和调度不需要OS内核的支持，是在语言（如Java）这一级处理的；而内核支持线程的创建、撤消和调度都需OS内核提供支持，而且与进程的创建、撤消和调度大体是相同的。</p><p>3 用户级线程执行系统调用指令时将导致其所属进程被中断，而内核支持线程执行系统调用指令时，只导致该线程被中断。</p><p>4 在只有用户级线程的系统内，CPU调度还是以进程为单位，处于运行状态的进程中的多个线程，由用户程序控制线程的轮换运行；在有内核支持线程的系统内，CPU调度则以线程为单位，由OS的线程调度程序负责线程的调度。</p><p>5 用户级线程的程序实体是运行在用户态下的程序，而内核支持线程的程序实体则是可以运行在任何状态下的程序。</p><p>优点：当有多个处理机时，一个进程的多个线程可以同时执行。</p><p>缺点：由内核进行调度。</p><p>优点：</p><p>线程的调度不需要内核直接参与，控制简单。</p><p>可以在不支持线程的操作系统中实现。</p><p>创建和销毁线程、线程切换代价等线程管理的代价比内核线程少得多。</p><p>允许每个进程定制自己的调度算法，线程管理比较灵活。</p><p>线程能够利用的表空间和堆栈空间比内核级线程多。</p><p>同一进程中只能同时有一个线程在运行，如果有一个线程使用了系统调用而阻塞，那么整个进程都会被挂起。另外，页面失效也会产生同样的问题。</p><p>缺点：</p><p>资源调度按照进程进行，多个处理机下，同一个进程中的线程只能在同一个处理机下分时复用</p><h4 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h4><p>　　用户级与内核级的多路复用，内核同一调度内核线程，每个内核线程对应n个用户线程</p><h4 id="linux操作系统的-NPTL"><a href="#linux操作系统的-NPTL" class="headerlink" title="　　linux操作系统的 NPTL　　　　"></a>　　linux操作系统的 NPTL　　　　</h4><p><strong>历史</strong></p><p>在内核2.6以前的调度实体都是进程，内核并没有真正支持线程。它是能过一个系统调用clone()来实现的，这个调用创建了一份调用进程的拷贝，跟fork()不同的是,这份进程拷贝完全共享了调用进程的地址空间。<code>LinuxThread</code>就是通过这个系统调用来提供线程在内核级的支持的(许多以前的线程实现都完全是在用户态，内核根本不知道线程的存在)。非常不幸的是，这种方法有相当多的地方没有遵循<code>POSIX</code>标准，特别是在信号处理，调度，进程间通信原语等方面。</p><p>很显然，为了改进<code>LinuxThread</code>必须得到内核的支持，并且需要重写线程库。为了实现这个需求，开始有两个相互竞争的项目：IBM启动的<code>NGTP(Next Generation POSIX Threads)</code>项目，以及<code>Redhat</code>公司的<code>NPTL</code>。在2003年的年中，IBM放弃了<code>NGTP</code>，也就是大约那时，<code>Redhat</code>发布了最初的<code>NPTL</code>。</p><p><code>NPTL</code>最开始在<code>redhat linux 9</code>里发布，现在从<code>RHEL3</code>起内核2.6起都支持<code>NPTL</code>，并且完全成了GNU C库的一部分。</p><p><strong>设计</strong></p><p><code>NPTL</code>使用了跟<code>LinuxThread</code>相同的办法，在内核里面线程仍然被当作是一个进程，并且仍然使用了clone()系统调用(在<code>NPTL</code>库里调用)。但是，<code>NPTL</code>需要内核级的特殊支持来实现，比如需要挂起然后再唤醒线程的线程同步原语<code>futex</code>.</p><p><code>NPTL</code>也是一个1*1的线程库，就是说，当你使用<code>pthread_create()</code>调用创建一个线程后，在内核里就相应创建了一个调度实体，在<code>linux</code>里就是一个新进程，这个方法最大可能的简化了线程的实现。</p><p>除<code>NPTL</code>的1*1模型外还有一个<code>m*n</code>模型，通常这种模型的用户线程数会比内核的调度实体多。在这种实现里，线程库本身必须去处理可能存在的调度，这样在线程库内部的上下文切换通常都会相当的快，因为它避免了系统调用转到内核态。然而这种模型增加了线程实现的复杂性,并可能出现诸如优先级反转的问题，此外，用户态的调度如何跟内核态的调度进行协调也是很难让人满意。</p><h2 id="线程和python"><a href="#线程和python" class="headerlink" title="线程和python"></a>线程和python</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><h4 id="全局解释器锁GIL"><a href="#全局解释器锁GIL" class="headerlink" title="全局解释器锁GIL"></a>全局解释器锁GIL</h4><p>　　Python代码的执行由Python虚拟机(也叫解释器主循环)来控制。Python在设计之初就考虑到要在主循环中，同时只有一个线程在执行。虽然 Python 解释器中可以“运行”多个线程，但在任意时刻只有一个线程在解释器中运行。</p><p>　　对Python虚拟机的访问由全局解释器锁(GIL)来控制，正是这个锁能保证同一时刻只有一个线程在运行。</p><p>　　在多线程环境中，Python 虚拟机按以下方式执行：</p><p>　　a、设置 GIL；</p><p>　　b、切换到一个线程去运行；</p><p>　　c、运行指定数量的字节码指令或者线程主动让出控制(可以调用 <code>time.sleep(0)</code>)；</p><p>　　d、把线程设置为睡眠状态；</p><p>　　e、解锁 GIL；</p><p>　　d、再次重复以上所有步骤。</p><p>　　在调用外部代码(如 C/C++扩展函数)的时候，GIL将会被锁定，直到这个函数结束为止(由于在这期间没有Python的字节码被运行，所以不会做线程切换)编写扩展的程序员可以主动解锁GIL。</p><h4 id="python线程模块的选择"><a href="#python线程模块的选择" class="headerlink" title="python线程模块的选择"></a>python线程模块的选择</h4><p>　　Python提供了几个用于多线程编程的模块，包括<code>thread</code>、<code>threading</code>和<code>Queue</code>等。<code>thread</code>和<code>threading</code>模块允许程序员创建和管理线程。thread模块提供了基本的线程和锁的支持，<code>threading</code>提供了更高级别、功能更强的线程管理的功能。Queue模块允许用户创建一个可以用于多个线程之间共享数据的队列数据结构。</p><p>　　避免使用thread模块，因为更高级别的<code>threading</code>模块更为先进，对线程的支持更为完善，而且使用<code>thread</code>模块里的属性有可能会与<code>threading</code>出现冲突；其次低级别的<code>thread</code>模块的同步原语很少(实际上只有一个)，而<code>threading</code>模块则有很多；再者，<code>thread</code>模块中当主线程结束时，所有的线程都会被强制结束掉，没有警告也不会有正常的清除工作，至少<code>threading</code>模块能确保重要的子线程退出后进程才退出。</p><p>　　<code>thread</code>模块不支持守护线程，当主线程退出时，所有的子线程不论它们是否还在工作，都会被强行退出。而<code>threading</code>模块支持守护线程，守护线程一般是一个等待客户请求的服务器，如果没有客户提出请求它就在那等着，如果设定一个线程为守护线程，就表示这个线程是不重要的，在进程退出的时候，不用等待这个线程退出。</p><h3 id="threading模块"><a href="#threading模块" class="headerlink" title="threading模块"></a>threading模块</h3><p><code>multiprocess</code>模块的完全模仿了<code>threading</code>模块的接口，二者在使用层面，有很大的相似性，因而不再详细介绍（官方链接）</p><h4 id="线程的创建Threading-Thread类"><a href="#线程的创建Threading-Thread类" class="headerlink" title="线程的创建Threading.Thread类"></a>线程的创建Threading.Thread类</h4><p><strong>线程的创建</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s say hello&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">&#x27;egon&#x27;</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line">创建线程的方式<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sayhi</span>(<span class="params">Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name=name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        print(<span class="string">&#x27;%s say hello&#x27;</span> % self.name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t = Sayhi(<span class="string">&#x27;egon&#x27;</span>)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line"></span><br><span class="line">创建线程的方式<span class="number">2</span></span><br></pre></td></tr></table></figure><p><strong>多线程与多进程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>,os.getpid())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#part1:在主进程下开启多个线程,每个线程都跟主进程的pid一样</span></span><br><span class="line">    t1=Thread(target=work)</span><br><span class="line">    t2=Thread(target=work)</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程pid&#x27;</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">    <span class="comment">#part2:开多个进程,每个进程都有不同的pid</span></span><br><span class="line">    p1=Process(target=work)</span><br><span class="line">    p2=Process(target=work)</span><br><span class="line">    p1.start()</span><br><span class="line">    p2.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程pid&#x27;</span>,os.getpid())</span><br><span class="line"></span><br><span class="line">pid的比较</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    print(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#在主进程下开启子进程</span></span><br><span class="line">    t=Process(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程&#x27;</span>)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    hello</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">开启效率的较量</span><br><span class="line"><span class="keyword">from</span>  threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># n=100</span></span><br><span class="line">    <span class="comment"># p=Process(target=work)</span></span><br><span class="line">    <span class="comment"># p.start()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line">    <span class="comment"># print(&#x27;主&#x27;,n) #毫无疑问子进程p已经将自己的全局的n改成了0,但改的仅仅是它自己的,查看父进程的n仍然为100</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    n=<span class="number">1</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">&#x27;主&#x27;</span>,n) <span class="comment">#查看结果为0,因为同一进程内的线程之间共享进程内的数据</span></span><br><span class="line">同一进程内的线程共享该进程的数据？</span><br><span class="line"></span><br><span class="line">内存数据的共享问题</span><br></pre></td></tr></table></figure><p><strong>练习 ：多线程实现socket</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">import</span> multiprocessing</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line">s.listen(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">action</span>(<span class="params">conn</span>):</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        data=conn.recv(<span class="number">1024</span>)</span><br><span class="line">        print(data)</span><br><span class="line">        conn.send(data.upper())</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        conn,addr=s.accept()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        p=threading.Thread(target=action,args=(conn,))</span><br><span class="line">        p.start()</span><br><span class="line"></span><br><span class="line">server</span><br><span class="line"><span class="comment">#_*_coding:utf-8_*_</span></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">s.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>,<span class="number">8080</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    msg=input(<span class="string">&#x27;&gt;&gt;: &#x27;</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    s.send(msg.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">    data=s.recv(<span class="number">1024</span>)</span><br><span class="line">    print(data)</span><br><span class="line"></span><br><span class="line">client</span><br></pre></td></tr></table></figure><p><strong>Thread类的其他方法</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Thread实例对象的方法</span><br><span class="line">  <span class="comment"># isAlive(): 返回线程是否活动的。</span></span><br><span class="line">  <span class="comment"># getName(): 返回线程名。</span></span><br><span class="line">  <span class="comment"># setName(): 设置线程名。</span></span><br><span class="line"></span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  <span class="comment"># threading.currentThread(): 返回当前的线程变量。</span></span><br><span class="line">  <span class="comment"># threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span></span><br><span class="line">  <span class="comment"># threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="keyword">import</span> time</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(threading.current_thread().getName())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#在主进程下开启线程</span></span><br><span class="line">    t=Thread(target=work)</span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    print(threading.current_thread().getName())</span><br><span class="line">    print(threading.current_thread()) <span class="comment">#主线程</span></span><br><span class="line">    print(threading.enumerate()) <span class="comment">#连同主线程在内有两个运行的线程</span></span><br><span class="line">    print(threading.active_count())</span><br><span class="line">    print(<span class="string">&#x27;主线程/主进程&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    打印结果:</span></span><br><span class="line"><span class="string">    MainThread</span></span><br><span class="line"><span class="string">    &lt;_MainThread(MainThread, started 140735268892672)&gt;</span></span><br><span class="line"><span class="string">    [&lt;_MainThread(MainThread, started 140735268892672)&gt;, &lt;Thread(Thread-1, started 123145307557888)&gt;]</span></span><br><span class="line"><span class="string">    主线程/主进程</span></span><br><span class="line"><span class="string">    Thread-1</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">代码示例</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s say hello&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">&#x27;egon&#x27;</span>,))</span><br><span class="line">    t.start()</span><br><span class="line">    t.join()</span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    egon say hello</span></span><br><span class="line"><span class="string">    主线程</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">join方法</span><br></pre></td></tr></table></figure><p><strong>守护线程</strong></p><p><strong>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。**</strong>需要强调的是：运行完毕并非终止运行**</p><p>无论是进程还是线程，都遵循：守护xx会等待主xx运行完毕后被销毁。需要强调的是：运行完毕并非终止运行</p><p>#1.对主进程来说，运行完毕指的是主进程代码运行完毕</p><p>#2.对主线程来说，运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕，主线程才算运行完毕</p><p>#1 主进程在其代码结束后就已经算运行完毕了（守护进程在此时就被回收）,然后主进程会一直等非守护的子进程都运行完毕后回收子进程的资源(否则会产生僵尸进程)，才会结束，</p><p>#2 主线程在其他非守护线程运行完毕后才算运行完毕（守护线程在此时就被回收）。因为主线程的结束意味着进程的结束，进程整体的资源都将被回收，而进程必须保证非守护线程都运行完毕后才能结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sayhi</span>(<span class="params">name</span>):</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s say hello&#x27;</span> %name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    t=Thread(target=sayhi,args=(<span class="string">&#x27;egon&#x27;</span>,))</span><br><span class="line">    t.setDaemon(<span class="literal">True</span>) <span class="comment">#必须在t.start()之前设置</span></span><br><span class="line">    t.start()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&#x27;主线程&#x27;</span>)</span><br><span class="line">    print(t.is_alive())</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    主线程</span></span><br><span class="line"><span class="string">    True</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">守护线程例<span class="number">1</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    print(<span class="number">123</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">&quot;end123&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span>():</span></span><br><span class="line">    print(<span class="number">456</span>)</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&quot;end456&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t1=Thread(target=foo)</span><br><span class="line">t2=Thread(target=bar)</span><br><span class="line"></span><br><span class="line">t1.daemon=<span class="literal">True</span></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">print(<span class="string">&quot;main-------&quot;</span>)</span><br><span class="line"></span><br><span class="line">守护线程例<span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><h4 id="锁与GIL"><a href="#锁与GIL" class="headerlink" title="锁与GIL"></a>锁与GIL</h4><h4><a href="#" class="headerlink"></a></h4><h4 id="同步锁"><a href="#同步锁" class="headerlink" title="同步锁"></a>同步锁</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p=Thread(target=work)</span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(n) <span class="comment">#结果可能为99</span></span><br><span class="line"></span><br><span class="line">多个线程抢占资源的情况</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">R=threading.Lock()</span><br><span class="line">R.acquire()</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">对公共数据的操作</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">R.release()</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">work</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.1</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line">    lock.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    lock=Lock()</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    l=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        p=Thread(target=work)</span><br><span class="line">        l.append(p)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> p <span class="keyword">in</span> l:</span><br><span class="line">        p.join()</span><br><span class="line"></span><br><span class="line">    print(n) <span class="comment">#结果肯定为0，由原来的并发执行变成串行，牺牲了执行效率保证了数据安全</span></span><br><span class="line"></span><br><span class="line">同步锁的引用</span><br><span class="line"><span class="comment">#不加锁:并发执行,速度快,数据不安全</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    print(<span class="string">&#x27;%s is running&#x27;</span> %current_thread().getName())</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    threads=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line"></span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">&#x27;主:%s n:%s&#x27;</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Thread-1 is running</span></span><br><span class="line"><span class="string">Thread-2 is running</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 is running</span></span><br><span class="line"><span class="string">主:0.5216062068939209 n:99</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#不加锁:未加锁部分并发执行,加锁部分串行执行,速度慢,数据安全</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    <span class="comment">#未加锁的代码并发运行</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s start to run&#x27;</span> %current_thread().getName())</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    <span class="comment">#加锁的代码串行运行</span></span><br><span class="line">    lock.acquire()</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line">    lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    threads=[]</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        threads.append(t)</span><br><span class="line">        t.start()</span><br><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> threads:</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">&#x27;主:%s n:%s&#x27;</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Thread-1 is running</span></span><br><span class="line"><span class="string">Thread-2 is running</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 is running</span></span><br><span class="line"><span class="string">主:53.294203758239746 n:0</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#有的同学可能有疑问:既然加锁会让运行变成串行,那么我在start之后立即使用join,就不用加锁了啊,也是串行的效果啊</span></span><br><span class="line"><span class="comment">#没错:在start之后立刻使用jion,肯定会将100个任务的执行变成串行,毫无疑问,最终n的结果也肯定是0,是安全的,但问题是</span></span><br><span class="line"><span class="comment">#start后立即join:任务内的所有代码都是串行执行的,而加锁,只是加锁的部分即修改共享数据的部分是串行的</span></span><br><span class="line"><span class="comment">#单从保证数据安全方面,二者都可以实现,但很明显是加锁的效率更高.</span></span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> current_thread,Thread,Lock</span><br><span class="line"><span class="keyword">import</span> os,time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>():</span></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">&#x27;%s start to run&#x27;</span> %current_thread().getName())</span><br><span class="line">    <span class="keyword">global</span> n</span><br><span class="line">    temp=n</span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    n=temp<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    n=<span class="number">100</span></span><br><span class="line">    lock=Lock()</span><br><span class="line">    start_time=time.time()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">        t=Thread(target=task)</span><br><span class="line">        t.start()</span><br><span class="line">        t.join()</span><br><span class="line">    stop_time=time.time()</span><br><span class="line">    print(<span class="string">&#x27;主:%s n:%s&#x27;</span> %(stop_time-start_time,n))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Thread-1 start to run</span></span><br><span class="line"><span class="string">Thread-2 start to run</span></span><br><span class="line"><span class="string">......</span></span><br><span class="line"><span class="string">Thread-100 start to run</span></span><br><span class="line"><span class="string">主:350.6937336921692 n:0 #耗时是多么的恐怖</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">）</span><br><span class="line"></span><br><span class="line">互斥锁与join的区别</span><br></pre></td></tr></table></figure><h4 id="死锁与递归锁"><a href="#死锁与递归锁" class="headerlink" title="死锁与递归锁"></a>死锁与递归锁</h4><p>进程也有死锁与递归锁，在进程那里忘记说了，放到这里一切说了额</p><p>所谓死锁： 是指两个或两个以上的进程或线程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程，如下就是死锁</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock <span class="keyword">as</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">mutexA=Lock()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">print(<span class="number">123</span>)</span><br><span class="line">mutexA.release()</span><br><span class="line">mutexA.release()</span><br><span class="line"></span><br><span class="line">死锁</span><br></pre></td></tr></table></figure><p>解决方法，递归锁，在Python中为了支持在同一线程中多次请求同一资源，python提供了可重入锁RLock。</p><p>这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。上面的例子如果使用RLock代替Lock，则不会发生死锁：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> RLock <span class="keyword">as</span> Lock</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line">mutexA=Lock()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">mutexA.acquire()</span><br><span class="line">print(<span class="number">123</span>)</span><br><span class="line">mutexA.release()</span><br><span class="line">mutexA.release()</span><br><span class="line"></span><br><span class="line">递归锁RLock</span><br></pre></td></tr></table></figure><p>典型问题：科学家吃面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,Lock</span><br><span class="line">noodle_lock = Lock()</span><br><span class="line">fork_lock = Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span>(<span class="params">name</span>):</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了面条&#x27;</span>%name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了叉子&#x27;</span>%name)</span><br><span class="line">    print(<span class="string">&#x27;%s 吃面&#x27;</span>%name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span>(<span class="params">name</span>):</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了叉子&#x27;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了面条&#x27;</span> % name)</span><br><span class="line">    print(<span class="string">&#x27;%s 吃面&#x27;</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;哪吒&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;yuan&#x27;</span>]:</span><br><span class="line">    t1 = Thread(target=eat1,args=(name,))</span><br><span class="line">    t2 = Thread(target=eat2,args=(name,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">死锁问题</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread,RLock</span><br><span class="line">fork_lock = noodle_lock = RLock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat1</span>(<span class="params">name</span>):</span></span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了面条&#x27;</span>%name)</span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了叉子&#x27;</span>%name)</span><br><span class="line">    print(<span class="string">&#x27;%s 吃面&#x27;</span>%name)</span><br><span class="line">    fork_lock.release()</span><br><span class="line">    noodle_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat2</span>(<span class="params">name</span>):</span></span><br><span class="line">    fork_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了叉子&#x27;</span> % name)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    noodle_lock.acquire()</span><br><span class="line">    print(<span class="string">&#x27;%s 抢到了面条&#x27;</span> % name)</span><br><span class="line">    print(<span class="string">&#x27;%s 吃面&#x27;</span> % name)</span><br><span class="line">    noodle_lock.release()</span><br><span class="line">    fork_lock.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> [<span class="string">&#x27;哪吒&#x27;</span>,<span class="string">&#x27;egon&#x27;</span>,<span class="string">&#x27;yuan&#x27;</span>]:</span><br><span class="line">    t1 = Thread(target=eat1,args=(name,))</span><br><span class="line">    t2 = Thread(target=eat2,args=(name,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line"></span><br><span class="line">递归锁解决死锁问题</span><br></pre></td></tr></table></figure><h3 id="线程队列"><a href="#线程队列" class="headerlink" title="线程队列"></a>线程队列</h3><p><strong>queue队列 ：使用import queue，用法与进程Queue一样</strong></p><p>queue is especially useful in threaded programming when information must be exchanged safely between multiple threads.</p><p><code>class queue.Queue(maxsize=0)</code> #先进先出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.Queue()</span><br><span class="line">q.put(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">q.put(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">q.put(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果(先进先出):</span></span><br><span class="line"><span class="string">first</span></span><br><span class="line"><span class="string">second</span></span><br><span class="line"><span class="string">third</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">先进先出</span><br></pre></td></tr></table></figure><p><code>class queue.LifoQueue(maxsize=0) #last in fisrt out</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">&#x27;first&#x27;</span>)</span><br><span class="line">q.put(<span class="string">&#x27;second&#x27;</span>)</span><br><span class="line">q.put(<span class="string">&#x27;third&#x27;</span>)</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果(后进先出):</span></span><br><span class="line"><span class="string">third</span></span><br><span class="line"><span class="string">second</span></span><br><span class="line"><span class="string">first</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">后进先出</span><br></pre></td></tr></table></figure><p>class queue.PriorityQueue(maxsize=0) #存储数据时可设置优先级的队列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"></span><br><span class="line">q=queue.PriorityQueue()</span><br><span class="line"><span class="comment">#put进入一个元组,元组的第一个元素是优先级(通常是数字,也可以是非数字之间的比较),数字越小优先级越高</span></span><br><span class="line">q.put((<span class="number">20</span>,<span class="string">&#x27;a&#x27;</span>))</span><br><span class="line">q.put((<span class="number">10</span>,<span class="string">&#x27;b&#x27;</span>))</span><br><span class="line">q.put((<span class="number">30</span>,<span class="string">&#x27;c&#x27;</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">结果(数字越小优先级越高,优先级高的优先出队):</span></span><br><span class="line"><span class="string">(10, &#x27;b&#x27;)</span></span><br><span class="line"><span class="string">(20, &#x27;a&#x27;)</span></span><br><span class="line"><span class="string">(30, &#x27;c&#x27;)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">优先级队列</span><br><span class="line">Constructor <span class="keyword">for</span> a priority queue. maxsize <span class="keyword">is</span> an integer that sets the upperbound limit on the number of items that can be placed <span class="keyword">in</span> the queue. Insertion will block once this size has been reached, until queue items are consumed. If maxsize <span class="keyword">is</span> less than <span class="keyword">or</span> equal to zero, the queue size <span class="keyword">is</span> infinite.</span><br><span class="line"></span><br><span class="line">The lowest valued entries are retrieved first (the lowest valued entry <span class="keyword">is</span> the one returned by sorted(list(entries))[<span class="number">0</span>]). A typical pattern <span class="keyword">for</span> entries <span class="keyword">is</span> a tuple <span class="keyword">in</span> the form: (priority_number, data).</span><br><span class="line"></span><br><span class="line">exception queue.Empty</span><br><span class="line">Exception raised when non-blocking get() (<span class="keyword">or</span> get_nowait()) <span class="keyword">is</span> called on a Queue object which <span class="keyword">is</span> empty.</span><br><span class="line"></span><br><span class="line">exception queue.Full</span><br><span class="line">Exception raised when non-blocking put() (<span class="keyword">or</span> put_nowait()) <span class="keyword">is</span> called on a Queue object which <span class="keyword">is</span> full.</span><br><span class="line"></span><br><span class="line">Queue.qsize()</span><br><span class="line">Queue.empty() <span class="comment">#return True if empty  </span></span><br><span class="line">Queue.full() <span class="comment"># return True if full </span></span><br><span class="line">Queue.put(item, block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line">Put item into the queue. If optional args block <span class="keyword">is</span> true <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="literal">None</span> (the default), block <span class="keyword">if</span> necessary until a free slot <span class="keyword">is</span> available. If timeout <span class="keyword">is</span> a positive number, it blocks at most timeout seconds <span class="keyword">and</span> raises the Full exception <span class="keyword">if</span> no free slot was available within that time. Otherwise (block <span class="keyword">is</span> false), put an item on the queue <span class="keyword">if</span> a free slot <span class="keyword">is</span> immediately available, <span class="keyword">else</span> <span class="keyword">raise</span> the Full exception (timeout <span class="keyword">is</span> ignored <span class="keyword">in</span> that case).</span><br><span class="line"></span><br><span class="line">Queue.put_nowait(item)</span><br><span class="line">Equivalent to put(item, <span class="literal">False</span>).</span><br><span class="line"></span><br><span class="line">Queue.get(block=<span class="literal">True</span>, timeout=<span class="literal">None</span>)</span><br><span class="line">Remove <span class="keyword">and</span> <span class="keyword">return</span> an item <span class="keyword">from</span> the queue. If optional args block <span class="keyword">is</span> true <span class="keyword">and</span> timeout <span class="keyword">is</span> <span class="literal">None</span> (the default), block <span class="keyword">if</span> necessary until an item <span class="keyword">is</span> available. If timeout <span class="keyword">is</span> a positive number, it blocks at most timeout seconds <span class="keyword">and</span> raises the Empty exception <span class="keyword">if</span> no item was available within that time. Otherwise (block <span class="keyword">is</span> false), <span class="keyword">return</span> an item <span class="keyword">if</span> one <span class="keyword">is</span> immediately available, <span class="keyword">else</span> <span class="keyword">raise</span> the Empty exception (timeout <span class="keyword">is</span> ignored <span class="keyword">in</span> that case).</span><br><span class="line"></span><br><span class="line">Queue.get_nowait()</span><br><span class="line">Equivalent to get(<span class="literal">False</span>).</span><br><span class="line"></span><br><span class="line">Two methods are offered to support tracking whether enqueued tasks have been fully processed by daemon consumer threads.</span><br><span class="line"></span><br><span class="line">Queue.task_done()</span><br><span class="line">Indicate that a formerly enqueued task <span class="keyword">is</span> complete. Used by queue consumer threads. For each get() used to fetch a task, a subsequent call to task_done() tells the queue that the processing on the task <span class="keyword">is</span> complete.</span><br><span class="line"></span><br><span class="line">If a join() <span class="keyword">is</span> currently blocking, it will resume when all items have been processed (meaning that a task_done() call was received <span class="keyword">for</span> every item that had been put() into the queue).</span><br><span class="line"></span><br><span class="line">Raises a ValueError <span class="keyword">if</span> called more times than there were items placed <span class="keyword">in</span> the queue.</span><br><span class="line"></span><br><span class="line">Queue.join() block直到queue被消费完毕</span><br><span class="line"></span><br><span class="line">更多方法说明</span><br></pre></td></tr></table></figure><h3 id="Python标准模块–concurrent-futures"><a href="#Python标准模块–concurrent-futures" class="headerlink" title="Python标准模块–concurrent.futures"></a>Python标准模块–concurrent.futures</h3><p><span class="exturl" data-url="aHR0cHM6Ly9kb2NzLnB5dGhvbi5vcmcvZGV2L2xpYnJhcnkvY29uY3VycmVudC5mdXR1cmVzLmh0bWw=">https://docs.python.org/dev/library/concurrent.futures.html<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1 介绍</span></span><br><span class="line">concurrent.futures模块提供了高度封装的异步调用接口</span><br><span class="line">ThreadPoolExecutor：线程池，提供异步调用</span><br><span class="line">ProcessPoolExecutor: 进程池，提供异步调用</span><br><span class="line">Both implement the same interface, which <span class="keyword">is</span> defined by the abstract Executor <span class="keyword">class</span>.</span><br><span class="line"></span><br><span class="line"><span class="comment">#2 基本方法</span></span><br><span class="line"><span class="comment">#submit(fn, *args, **kwargs)</span></span><br><span class="line">异步提交任务</span><br><span class="line"></span><br><span class="line"><span class="comment">#map(func, *iterables, timeout=None, chunksize=1) </span></span><br><span class="line">取代<span class="keyword">for</span>循环submit的操作</span><br><span class="line"></span><br><span class="line"><span class="comment">#shutdown(wait=True) </span></span><br><span class="line">相当于进程池的pool.close()+pool.join()操作</span><br><span class="line">wait=<span class="literal">True</span>，等待池内所有任务执行完毕回收完资源后才继续</span><br><span class="line">wait=<span class="literal">False</span>，立即返回，并不会等待池内的任务执行完毕</span><br><span class="line">但不管wait参数为何值，整个程序都会等到所有任务执行完毕</span><br><span class="line">submit和map必须在shutdown之前</span><br><span class="line"></span><br><span class="line"><span class="comment">#result(timeout=None)</span></span><br><span class="line">取得结果</span><br><span class="line"></span><br><span class="line"><span class="comment">#add_done_callback(fn)</span></span><br><span class="line">回调函数</span><br><span class="line"></span><br><span class="line"><span class="comment"># done()</span></span><br><span class="line">判断某一个线程是否完成</span><br><span class="line"></span><br><span class="line"><span class="comment"># cancle()</span></span><br><span class="line">取消某个任务</span><br><span class="line"><span class="comment">#介绍</span></span><br><span class="line">The ProcessPoolExecutor class is an Executor subclass that uses a pool of processes to execute calls asynchronously. ProcessPoolExecutor uses the multiprocessing module, which allows it to side-step the Global Interpreter Lock but also means that only picklable objects can be executed and returned.</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concurrent</span>.<span class="title">futures</span>.<span class="title">ProcessPoolExecutor</span>(<span class="params">max_workers=None, mp_context=None</span>)</span></span><br><span class="line">An Executor subclass that executes calls asynchronously using a pool of at most max_workers processes. If max_workers is None or not given, it will default to the number of processors on the machine. If max_workers is lower or equal to 0, then a ValueError will be raised.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#用法</span></span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s is runing&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    executor=ProcessPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    futures=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">11</span>):</span><br><span class="line">        future=executor.submit(task,i)</span><br><span class="line">        futures.append(future)</span><br><span class="line">    executor.shutdown(<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">&#x27;+++&gt;&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> future <span class="keyword">in</span> futures:</span><br><span class="line">        print(future.result())</span><br><span class="line"></span><br><span class="line">ProcessPoolExecutor</span><br><span class="line"><span class="comment">#介绍</span></span><br><span class="line">ThreadPoolExecutor <span class="keyword">is</span> an Executor subclass that uses a pool of threads to execute calls asynchronously.</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">concurrent</span>.<span class="title">futures</span>.<span class="title">ThreadPoolExecutor</span>(<span class="params">max_workers=None, thread_name_prefix=<span class="string">&#x27;&#x27;</span></span>)</span></span><br><span class="line"><span class="class"><span class="title">An</span> <span class="title">Executor</span> <span class="title">subclass</span> <span class="title">that</span> <span class="title">uses</span> <span class="title">a</span> <span class="title">pool</span> <span class="title">of</span> <span class="title">at</span> <span class="title">most</span> <span class="title">max_workers</span> <span class="title">threads</span> <span class="title">to</span> <span class="title">execute</span> <span class="title">calls</span> <span class="title">asynchronously</span>.</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">Changed</span> <span class="title">in</span> <span class="title">version</span> 3.5:</span> If max_workers <span class="keyword">is</span> <span class="literal">None</span> <span class="keyword">or</span> <span class="keyword">not</span> given, it will default to the number of processors on the machine, multiplied by <span class="number">5</span>, assuming that ThreadPoolExecutor <span class="keyword">is</span> often used to overlap I/O instead of CPU work <span class="keyword">and</span> the number of workers should be higher than the number of workers <span class="keyword">for</span> ProcessPoolExecutor.</span><br><span class="line"></span><br><span class="line">New <span class="keyword">in</span> version <span class="number">3.6</span>: The thread_name_prefix argument was added to allow users to control the threading.Thread names <span class="keyword">for</span> worker threads created by the pool <span class="keyword">for</span> easier debugging.</span><br><span class="line"></span><br><span class="line"><span class="comment">#用法</span></span><br><span class="line">与ProcessPoolExecutor相同</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> os,time,random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span>(<span class="params">n</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s is runing&#x27;</span> %os.getpid())</span><br><span class="line">    time.sleep(random.randint(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">return</span> n**<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    executor=ThreadPoolExecutor(max_workers=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># for i in range(11):</span></span><br><span class="line">    <span class="comment">#     future=executor.submit(task,i)</span></span><br><span class="line"></span><br><span class="line">    executor.map(task,range(<span class="number">1</span>,<span class="number">12</span>)) <span class="comment">#map取代了for+submit</span></span><br><span class="line"></span><br><span class="line">map的用法</span><br><span class="line"><span class="keyword">from</span> concurrent.futures <span class="keyword">import</span> ThreadPoolExecutor,ProcessPoolExecutor</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span>(<span class="params">url</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;&lt;进程%s&gt; get %s&#x27;</span> %(os.getpid(),url))</span><br><span class="line">    respone=requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> respone.status_code == <span class="number">200</span>:</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&#x27;url&#x27;</span>:url,<span class="string">&#x27;text&#x27;</span>:respone.text&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_page</span>(<span class="params">res</span>):</span></span><br><span class="line">    res=res.result()</span><br><span class="line">    print(<span class="string">&#x27;&lt;进程%s&gt; parse %s&#x27;</span> %(os.getpid(),res[<span class="string">&#x27;url&#x27;</span>]))</span><br><span class="line">    parse_res=<span class="string">&#x27;url:&lt;%s&gt; size:[%s]\n&#x27;</span> %(res[<span class="string">&#x27;url&#x27;</span>],len(res[<span class="string">&#x27;text&#x27;</span>]))</span><br><span class="line">    <span class="keyword">with</span> open(<span class="string">&#x27;db.txt&#x27;</span>,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(parse_res)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    urls=[</span><br><span class="line">        <span class="string">&#x27;https://www.baidu.com&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.python.org&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://www.openstack.org&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://help.github.com/&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;http://www.sina.com.cn/&#x27;</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># p=Pool(3)</span></span><br><span class="line">    <span class="comment"># for url in urls:</span></span><br><span class="line">    <span class="comment">#     p.apply_async(get_page,args=(url,),callback=pasrse_page)</span></span><br><span class="line">    <span class="comment"># p.close()</span></span><br><span class="line">    <span class="comment"># p.join()</span></span><br><span class="line"></span><br><span class="line">    p=ProcessPoolExecutor(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> url <span class="keyword">in</span> urls:</span><br><span class="line">        p.submit(get_page,url).add_done_callback(parse_page) <span class="comment">#parse_page拿到的是一个future对象obj，需要用obj.result()拿到结果</span></span><br><span class="line"></span><br><span class="line">回调函数</span><br></pre></td></tr></table></figure></div><div class="popular-posts-header">相关文章</div><ul class="popular-posts"><li class="popular-posts-item"><div class="popular-posts-title"><a href="/866c5c12.html" rel="bookmark">TCP网络应用程序开发流程回顾</a></div></li></ul><footer class="post-footer"><div class="reward-container"><div>打赏个鸡腿</div><button onclick='document.querySelector(".post-reward").classList.toggle("active")'>赞赏</button><div class="post-reward"><div><img src="/images/wechatpay.jpg" alt="托小尼 微信"> <span>微信</span></div><div><img src="/images/alipay.jpg" alt="托小尼 支付宝"> <span>支付宝</span></div></div></div><div class="post-tags"><a href="/tags/Process/" rel="tag"><i class="fa fa-tag"></i> Process</a> <a href="/tags/%E8%BF%9B%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 进程</a> <a href="/tags/%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> 线程</a> <a href="/tags/python%E8%BF%9B%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> python进程</a> <a href="/tags/python%E7%BA%BF%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> python线程</a> <a href="/tags/threding/" rel="tag"><i class="fa fa-tag"></i> threding</a> <a href="/tags/gil/" rel="tag"><i class="fa fa-tag"></i> gil</a> <a href="/tags/nptl/" rel="tag"><i class="fa fa-tag"></i> nptl</a></div><div class="post-nav"><div class="post-nav-item"><a href="/4c46dfcd.html" rel="prev" title="python多人登录上传下载其他功能后续加入"><i class="fa fa-chevron-left"></i> python多人登录上传下载其他功能后续加入</a></div><div class="post-nav-item"><a href="/c955ff7b.html" rel="next" title="记录一个python单线程、多线程简单爬虫的执行效率">记录一个python单线程、多线程简单爬虫的执行效率 <i class="fa fa-chevron-right"></i></a></div></div></footer></article><div class="comments"><div id="SOHUCS"></div></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div></main><footer class="footer"><div class="footer-inner"><div class="beian"><span class="exturl" data-url="aHR0cHM6Ly9iZWlhbi5taWl0Lmdvdi5jbg==">豫ICP备17028303号-1 </span><img src="http://www.beian.gov.cn/portal/download" style="display:inline-block"><span class="exturl" data-url="aHR0cDovL3d3dy5iZWlhbi5nb3YuY24vcG9ydGFsL3JlZ2lzdGVyU3lzdGVtSW5mbz9yZWNvcmRjb2RlPTE3MDI4MzAz">豫公网安备 41102402000095号</span></div><div class="copyright">&copy; <span itemprop="copyrightYear">2021</span> <span class="with-love"><i class="fa fa-user"></i> </span><span class="author" itemprop="copyrightHolder">Tony Yu</span></div><div class="wordcount"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-chart-line"></i> </span><span title="站点总字数">1.2m</span> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="站点阅读时长">18:43</span></span></div></div></footer><script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script><script src="//cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js"></script><script src="//cdn.jsdelivr.net/npm/lozad@1.15.0/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/local-search.js"></script><script>NexT.utils.loadComments('#SOHUCS', () => {
    NexT.utils.getScript('https://changyan.sohu.com/upload/changyan.js', () => {
      window.changyan.api.config({
        appid: 'cyu11Umgd',
        conf : '0f296687f6a61e82028fd7c6ddf32ab9'
      });
    });
  });</script><script src="https://assets.changyan.sohu.com/upload/plugins/plugins.count.js"></script></body></html>